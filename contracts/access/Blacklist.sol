// SPDX-License-Identifier: MIT
// Beef Access Contracts v0.0.0 hello@mcdu.com

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";

import "../utils/Array.sol";
import "./Trustable.sol";

interface IBlacklist {
    event Blacklisted(address indexed bad, bool approved);

    function getBlacklisteds() external view returns (address[] memory);

    function isBlacklisted(address bad) external view returns (bool);
}

interface IRBlacklist {
    function setBlacklisted(address bad_, bool approved_) external;
}

abstract contract Blacklist is IERC165, Trustable, IBlacklist, IRBlacklist {
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          supportsInterface
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IERC165, Trustable)
        returns (bool)
    {
        return
            Trustable.supportsInterface(interfaceId) ||
            interfaceId == type(IBlacklist).interfaceId ||
            interfaceId == type(IRBlacklist).interfaceId;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          using
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    using Array for address[];
    using Array for bytes32[];

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          attributes
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    address[] internal _bads;

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          constructor
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //constructor(address referral_) Referral(referral_) {
    //}

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          modifiers
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    modifier notBlacklisted() {
        require(!isBlacklisted(_msgSender()), "Blacklist: caller is blacklisted");
        _;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          restricted public/external functions
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function setBlacklisted(address bad_, bool approved_) external {
        //onlyOwner || onlyTrusted
        require(!isReferred(), "referred");
        require(
            isTrusted(_msgSender()) || isOwner(_msgSender()),
            "Blacklist: caller is not owner or trusted"
        );
        if (approved_) _bads.insert(bad_);
        else _bads.remove(bad_);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          public/external view functions
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function getBlacklisteds() public view returns (address[] memory) {
        return _bads;
    }

    function isBlacklisted(address bad_) public view returns (bool) {
        if (isReferred()) return Blacklist(referral()).isBlacklisted(bad_);
        return _bads.s_exist(bad_);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          public/external functions
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
